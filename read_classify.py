#!/usr/bin/env python
# suppose both SAM file is sorted by alphabetical order according to read name
# usage:
# python read_classify.py suffix1 suffix2
# required:
#   suffix1.sam, suffix2.sam: sorted sam file
#   suffix1.header, suffix2.header: header of SAM format.
#      Usually generated by "grep '^@' suffix1_unsort.sam > suffix1.header"
# outputs:
#   suffix1_orig.sam, suffix2_orig.sam: reads comming from suffix1/suffix2
#   suffix1_other.sam, suffix2_other.sam: reads comming from the other species
#   suffix1_common.sam, suffix2_common.sam: reads whose sequence includes in both genome
#   suffix1_ambi.sam, suffix2_ambi.sam: reads whose sequence is not close to both genome
#   suffix1_unmapped.sam, suffix2_unmapped.sam: unmapped reads

import sys
MIN_MUTATE = 11
UNMAPPED = 100

def is_mapped(cols):
    flag = int(cols[1])
    if flag & 0x4 == 0:
        return True
    return False

def num_of_mismatches(cols):
    for i in range(12,len(cols)):
        tag_value = cols[i].split(":")
        if tag_value[0] == "XM" or tag_value[0] == "nM":
            # XM is for bowtie, nM is for star
            return int(tag_value[2])
    return UNMAPPED # unmapped

def output_single_tag(fp, tag):
    if tag["name"] != "":
        fp.write("\t".join(tag["cols"]) + "\n")
    return

def output_paired_tags(sp1_first_cols, sp2_first_cols, sp1_last_cols, sp2_last_cols):
    global sp1_fp_orig
    global sp2_fp_orig
    global sp1_fp_other
    global sp2_fp_other
    global sp1_fp_ambi
    global sp2_fp_ambi
    global sp1_fp_common
    global sp2_fp_common
    global sp1_fp_unmapped
    global sp2_fp_unmapped

    sp1_first_nm = UNMAPPED
    sp2_first_nm = UNMAPPED
    sp1_last_nm = UNMAPPED
    sp2_last_nm = UNMAPPED

    if(sp1_first_cols == "" or sp1_last_cols == "" or
       sp2_first_cols == "" or sp2_last_cols == ""):
        return "assingle"
    # count number of mismatches
    if is_mapped(sp1_first_cols):
        sp1_first_nm = num_of_mismatches(sp1_first_cols)
    if is_mapped(sp2_first_cols):
        sp2_first_nm = num_of_mismatches(sp2_first_cols)
    if is_mapped(sp1_last_cols):
        sp1_last_nm = num_of_mismatches(sp1_last_cols)
    if is_mapped(sp2_last_cols):
        sp2_last_nm = num_of_mismatches(sp2_last_cols)

    if (sp1_first_cols == UNMAPPED or sp2_first_cols == UNMAPPED or
        sp1_last_cols == UNMAPPED or sp2_last_cols == UNMAPPED):
        category = "assingle"
        return category

    category = "" # set status
    print("NUM_MISS %d %d %d %d" % (sp1_first_nm, sp2_first_nm, sp1_last_nm, sp2_last_nm))

    if min(sp1_first_nm, sp2_first_nm) < MIN_MUTATE:
        if min(sp1_last_nm, sp2_last_nm) < MIN_MUTATE:
            if sp1_first_nm == sp2_first_nm:
                if sp1_last_nm == sp2_last_nm:
                    category = "common"
                    output_common(sp1_first_cols, sp2_first_cols, 
                                  sp1_last_cols,  sp2_last_cols)
                elif sp1_last_nm < sp2_last_nm:
                    category = "orig"
                    output_orig(sp1_first_cols, sp2_first_cols, 
                                sp1_last_cols,  sp2_last_cols)
                else:
                    category = "other"
                    output_other(sp1_first_cols, sp2_first_cols, 
                                 sp1_last_cols,  sp2_last_cols)
            elif sp1_first_nm < sp2_first_nm:
                if sp1_last_nm <= sp2_last_nm:
                    category = "orig"
                    output_orig(sp1_first_cols, sp2_first_cols, 
                                sp1_last_cols,  sp2_last_cols)
                else:
                    category = "opps"
                    sp1_fp_orig.write("\t".join(sp1_first_cols) + "\n")
                    sp2_fp_other.write("\t".join(sp2_first_cols) + "\n")
                    sp1_fp_other.write("\t".join(sp1_last_cols) + "\n")
                    sp2_fp_orig.write("\t".join(sp2_last_cols) + "\n")
            else: # sp1_first_nm > sp2_first_nm
                if sp1_last_nm >= sp2_last_nm:
                    category = "other"
                    output_other(sp1_first_cols, sp2_first_cols, 
                                 sp1_last_cols,  sp2_last_cols)
                else: # sp1_last_nm < sp2_last_nm
                    category = "opps"
                    sp1_fp_other.write("\t".join(sp1_first_cols) + "\n")
                    sp2_fp_orig.write("\t".join(sp2_first_cols) + "\n")
                    sp1_fp_orig.write("\t".join(sp1_last_cols) + "\n")
                    sp2_fp_other.write("\t".join(sp2_last_cols) + "\n")
        else: 
            # (sp1_first_nm < MIN_MUTATE and sp2_first_nm < MIN_MUTATE) 
            # but unmapped or not (sp1_last_nm < 3 and sp2_last_nm < 3):
            category = "assingle"
    else:
        # unmapped or not (sp1_first_nm < MIN_MUTATE and sp2_first_nm < MIN_MUTATE)
        category = "assingle"

    print("-- category: %s\tsp1_fst:%d\tsp2_fst:%d\tsp1_lst:%d\tsp2_lst:%d" % (category, sp1_first_nm, sp2_first_nm, sp1_last_nm, sp2_last_nm))
    
    return category

def output_common(sp1_first, sp2_first, sp1_last, sp2_last):
    global sp1_fp_common
    global sp2_fp_common
    sp1_fp_common.write("\t".join(sp1_first) + "\n")
    sp2_fp_common.write("\t".join(sp2_first) + "\n")
    sp1_fp_common.write("\t".join(sp1_last) + "\n")
    sp2_fp_common.write("\t".join(sp2_last) + "\n")

def output_orig(sp1_first, sp2_first, sp1_last, sp2_last):
    global sp1_fp_orig
    global sp2_fp_other
    sp1_fp_orig.write("\t".join(sp1_first) + "\n")
    sp2_fp_other.write("\t".join(sp2_first) + "\n")
    sp1_fp_orig.write("\t".join(sp1_last) + "\n")
    sp2_fp_other.write("\t".join(sp2_last) + "\n")

def output_other(sp1_first, sp2_first, sp1_last, sp2_last):
    global sp1_fp_other
    global sp2_fp_orig
    sp1_fp_other.write("\t".join(sp1_first) + "\n")
    sp2_fp_orig.write("\t".join(sp2_first) + "\n")
    sp1_fp_other.write("\t".join(sp1_last) + "\n")
    sp2_fp_orig.write("\t".join(sp2_last) + "\n")


def output_tags(sp1_cols, sp2_cols):
    global sp1_fp_orig
    global sp2_fp_orig
    global sp1_fp_other
    global sp2_fp_other
    global sp1_fp_common
    global sp2_fp_common
    global sp1_fp_ambi
    global sp2_fp_ambi
    global sp1_fp_unmapped
    global sp2_fp_unmapped

    sp1_nm = UNMAPPED
    sp2_nm = UNMAPPED

    if is_mapped(sp1_cols):
        sp1_nm = num_of_mismatches(sp1_cols)
    if is_mapped(sp2_cols):
        sp2_nm = num_of_mismatches(sp2_cols)
    category = ""

    if sp1_nm == UNMAPPED or sp2_nm == UNMAPPED:
        category = "unmapped"
        sp1_fp_unmapped.write("\t".join(sp1_cols) + "\n")
        sp2_fp_unmapped.write("\t".join(sp2_cols) + "\n")
    elif sp1_nm >= MIN_MUTATE and sp2_nm >= MIN_MUTATE:
        category = "ambi"
        sp1_fp_ambi.write("\t".join(sp1_cols) + "\n")
        sp2_fp_ambi.write("\t".join(sp2_cols) + "\n")
    elif sp1_nm == sp2_nm:
        category = "common"
        sp1_fp_common.write("\t".join(sp1_cols) + "\n")
        sp2_fp_common.write("\t".join(sp2_cols) + "\n")
    elif sp1_nm > sp2_nm and sp2_nm < MIN_MUTATE:
        category = "other"
        sp1_fp_other.write("\t".join(sp1_cols) + "\n")
        sp2_fp_orig.write("\t".join(sp2_cols) + "\n")
    elif sp1_nm < sp2_nm and sp1_nm < MIN_MUTATE:
        category = "orig"
        sp1_fp_orig.write("\t".join(sp1_cols) + "\n")
        sp2_fp_other.write("\t".join(sp2_cols) + "\n")
    else:
        print "WARNING: non matched read: " + sp1_cols[0] + "\t" + tag
    #print "Classified: " + sp1_cols[0] + "\t" + str(sp1_nm) + "\t" + str(sp2_nm) + "\t" + category
    return category

def read_newline(line, first, last):
    cols = line[:-1].split("\t")
    if (first["name"] != "" and cols[0] != first["name"]) or (last["name"] != "" and cols[0] != last["name"]):
        return [first, last, "break"]
    #if int(cols[1]) & 0x40 != 0  and first["name"] == "":
    if int(cols[1]) & 0x40 != 0:
        if first["name"] == "" or int(cols[1]) & 0x100 == 0:
            first["name"] = cols[0]
            first["cols"] = cols
            # skip if secondary alignment
    elif int(cols[1]) & 0x80 != 0:
        if last["name"] == "" or int(cols[1]) & 0x100 == 0:
            last["name"] = cols[0]
            last["cols"] = cols
    else:
        print "WARNING: This tag is nether first nor last:" + cols[0]
    return [first,last, "cont"]

def read_nexttag(fp, line):
    first = {"name":"","cols":""}
    last = {"name":"","cols":""}
    while line:
        [first, last, status] = read_newline(line, first, last)
        if status == "break":
            break
        line = fp.readline()
    #print "READ: " + first["name"] + ", " + last["name"]
    return [first, last, line]


def main():
    global sp1_fp_orig
    global sp2_fp_orig
    global sp1_fp_other
    global sp2_fp_other
    global sp1_fp_common
    global sp2_fp_common
    global sp1_fp_ambi
    global sp2_fp_ambi
    global sp1_fp_unmapped
    global sp2_fp_unmapped


    cur_id = ""
    first_seg = 0
    last_seg = 0

    file1 = sys.argv[1]
    file2 = sys.argv[2]

    sp1_fp = open(file1 + ".sam", "r")
    sp2_fp = open(file2 + ".sam", "r")

    sp1_fp_orig = open(file1 + "_orig.sam", "w")
    sp2_fp_orig = open(file2 + "_orig.sam", "w")
    sp1_fp_other = open(file1 + "_other.sam", "w")
    sp2_fp_other = open(file2 + "_other.sam", "w")
    sp1_fp_common = open(file1 + "_common.sam", "w")
    sp2_fp_common = open(file2 + "_common.sam", "w")
    sp1_fp_ambi = open(file1 + "_ambi.sam", "w")
    sp2_fp_ambi = open(file2 + "_ambi.sam", "w")
    sp1_fp_unmapped = open(file1 + "_unmapped.sam", "w")
    sp2_fp_unmapped = open(file2 + "_unmapped.sam", "w")

    for fp in [
        sp1_fp_orig,
        sp1_fp_other,
        sp1_fp_common,
        sp1_fp_ambi,
        sp1_fp_unmapped,
        ]:
        for line in open(file1 + ".header", "r"):
            fp.write(line)

    for fp in [
        sp2_fp_orig,
        sp2_fp_other,
        sp2_fp_common,
        sp2_fp_ambi,
        sp2_fp_unmapped,
        ]:
        for line in open(file2 + ".header", "r"):
            fp.write(line)


    sp1_line = sp1_fp.readline()
    while sp1_line:
        if not sp1_line[0] == "@":
            break
        sp1_line = sp1_fp.readline()

    sp2_line = sp2_fp.readline()
    while sp2_line:
        if not sp2_line[0] == "@":
            break
        sp2_line = sp2_fp.readline()

    sp1_curid = ""
    sp2_curid = ""
    count_category = {"common":0,"orig":0,"other":0,"ambi":0,"unmapped":0,"opps":0,"assingle":0}
    category = ""

    sp1_first = {"name":"","cols":""}
    sp1_last = {"name":"","cols":""}
    sp2_first = {"name":"","cols":""}
    sp2_last = {"name":"","cols":""}
    sys.stdout.write("Read SP1\t")
    [sp1_first, sp1_last, sp1_line] = read_nexttag(sp1_fp, sp1_line)
    sys.stdout.write("Read SP2\t")
    [sp2_first, sp2_last, sp2_line] = read_nexttag(sp2_fp, sp2_line)

    while sp1_line and sp2_line:
        sp1_read_next = False
        sp2_read_next = False
        first_output_tag = False
        last_output_tag = False
        
        category = ""
        print "SP1 FIRST:" + ":".join(sp1_first["name"].split(":")[5:7]) + ",\tSP2 FIRST:" + ":".join(sp2_first["name"].split(":")[5:7]) + "\t",
        print "SP1 LAST: " + ":".join(sp1_last["name"].split(":")[5:7]) + ",\tSP2 LAST :" + ":".join(sp2_last["name"].split(":")[5:7])
        if (sp1_first["name"] != "" and sp1_last["name"] != "" and
            sp2_first["name"] != "" and sp2_last["name"] != "" and
            sp1_first["name"] == sp2_first["name"] and
            sp1_last["name"] == sp2_last["name"]):
            # both first and last tags can be mapped and have identical name
                category = output_paired_tags(sp1_first["cols"], sp2_first["cols"], sp1_last["cols"], sp2_last["cols"])
                count_category[category] += 2
                sp1_read_next = True
                sp2_read_next = True
                print "PAIRED: \t" + category
        #print "CATEGORY:" + category
        if not (category == "" or category == "assingle"):
            # output as paired tags
            [sp1_first, sp1_last, sp1_line] = read_nexttag(sp1_fp, sp1_line)
            [sp2_first, sp2_last, sp2_line] = read_nexttag(sp2_fp, sp2_line)
            continue
        # Treat as single read
        if sp1_first["name"] != "" and sp2_first["name"] != "":
            if sp1_first["name"] == sp2_first["name"]:
                # first tags on both species are mapped
                category = output_tags(sp1_first["cols"], sp2_first["cols"])
                count_category[category] += 1
                first_output_tag = True
                sp1_read_next = True
                sp2_read_next = True
                print "FIRST: =\t" + category
            elif sp1_first["name"] < sp2_first["name"]:
                sp1_read_next = True
                print "FIRST: <"
            else:
                sp2_read_next = True
                print "FIRST: >"
        if sp1_last["name"] != "" and sp2_last["name"] != "":
            if sp1_last["name"] == sp2_last["name"]:
                category = output_tags(sp1_last["cols"], sp2_last["cols"])
                count_category[category] += 1
                last_output_tag = True
                sp1_read_next = True
                sp2_read_next = True
                print "LAST: =\t" + category
            elif sp1_last["name"] < sp2_last["name"]:
                sp1_read_next = True
                print "LAST: <"
            else:
                sp2_read_next = True
                print "LAST: >"
        print "STATES: " + str(sp1_read_next) + "\t" + str(sp2_read_next)
        if category != "":
            if first_output_tag == False:
                output_single_tag(sp1_fp_unmapped, sp1_first)
                output_single_tag(sp2_fp_unmapped, sp2_first)
            if last_output_tag == False:
                output_single_tag(sp1_fp_unmapped, sp1_last)
                output_single_tag(sp2_fp_unmapped, sp2_last)
            [sp1_first, sp1_last, sp1_line] = read_nexttag(sp1_fp, sp1_line)
            [sp2_first, sp2_last, sp2_line] = read_nexttag(sp2_fp, sp2_line)
            continue
        if sp1_read_next == True:
            output_single_tag(sp1_fp_unmapped, sp1_first)
            output_single_tag(sp1_fp_unmapped, sp1_last)
            [sp1_first, sp1_last, sp1_line] = read_nexttag(sp1_fp, sp1_line)
        if sp2_read_next == True:
            output_single_tag(sp2_fp_unmapped, sp2_first)
            output_single_tag(sp2_fp_unmapped, sp2_last)
            [sp2_first, sp2_last, sp2_line] = read_nexttag(sp2_fp, sp2_line)
        if sp1_read_next == False and sp2_read_next == False:
            print "READ Both"
            output_single_tag(sp1_fp_unmapped, sp1_first)
            output_single_tag(sp1_fp_unmapped, sp1_last)
            output_single_tag(sp2_fp_unmapped, sp2_first)
            output_single_tag(sp2_fp_unmapped, sp2_last)
            [sp1_first, sp1_last, sp1_line] = read_nexttag(sp1_fp, sp1_line)
            [sp2_first, sp2_last, sp2_line] = read_nexttag(sp2_fp, sp2_line)

    if (sp1_first["name"] != "" and sp1_last["name"] != "" and
        sp2_first["name"] != "" and sp2_last["name"] != "" and
        sp1_first["name"] == sp2_first["name"] and
        sp1_last["name"] == sp2_last["name"]):
        category = output_paired_tags(sp1_first["cols"], sp2_first["cols"], 
                                      sp1_last["cols"], sp2_last["cols"])
        count_category[category] += 2
        print "PAIRED: \t" + category
    if category == "" or category == "assingle":
        if not (sp1_first["name"] == "" or sp2_first["name"] == ""):
            if sp1_first["name"] == sp2_first["name"]:
                if not sp1_first["name"] == "":
                    category = output_tags(sp1_first["cols"], sp2_first["cols"])
                count_category[category] += 1
                print "FIRST: =\t" + category
            else:
                print "First Unmapped"
                output_single_tag(sp1_fp_unmapped, sp1_first)
                output_single_tag(sp2_fp_unmapped, sp2_first)
        if not (sp1_last["name"] == "" or sp2_last["name"] == ""):
            if sp1_last["name"] == sp2_last["name"]:
                if not sp1_last["name"] == "":
                    category = output_tags(sp1_last["cols"], sp2_last["cols"])
                count_category[category] += 1
                print "LAST: =\t" + category
            else:
                print "Last Unmapped"
                output_single_tag(sp1_fp_unmapped, sp1_last)
                output_single_tag(sp2_fp_unmapped, sp2_last)
    while sp1_line:
        output_single_tag(sp1_fp_unmapped, sp1_first)
        output_single_tag(sp1_fp_unmapped, sp1_last)
        [sp1_first, sp1_last, sp1_line] = read_nexttag(sp1_fp, sp1_line)
    while sp2_line:
        output_single_tag(sp2_fp_unmapped, sp2_first)
        output_single_tag(sp2_fp_unmapped, sp2_last)
        sys.stdout.write("Read SP2 / scrap\t")
        [sp2_first, sp2_last, sp2_line] = read_nexttag(sp2_fp, sp2_line)


    for i in ["common","orig","other","ambi","unmapped","opps"]:
        print i + "\t" + str(count_category[i])

    #for key in sorted(count_mismatch.keys()):
    #    print key + "\t" + str(count_mismatch[key])

    sp1_fp_orig.close()
    sp1_fp_other.close()
    sp1_fp_common.close()
    sp1_fp_ambi.close()
    sp1_fp_unmapped.close()

    sp2_fp_orig.close()
    sp2_fp_other.close()
    sp2_fp_common.close()
    sp2_fp_ambi.close()
    sp2_fp_unmapped.close()

if __name__ == '__main__':
    main()
